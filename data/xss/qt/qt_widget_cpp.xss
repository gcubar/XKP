#include "widget.h"
#include "ui_qt_app.h"

<xss:e value="main_class"/>::<xss:e value="main_class"/>(QWidget *parent) :
    QWidget(parent),
    ui(new Ui::<xss:e value="main_class"/>)
{
    ui->setupUi(this);

    XKPPlacementLayout *layout;

<xss:class entry_point="generate_layouts">
    method qt_placement(string pl)
    {
        for(int i = 0; i < xs_placement_values.size; ++i)
        {
            if(xs_placement_values[i] == pl)
                return qt_placement_values[i];
        }
        
        return qt_placement_values[0];
    }
  
    method generate_layouts()
	{
	    int idx = 0;
		int size = 1;

	    array<var> queue = [];
		queue += application;

		var parent = null;

		while(idx < size)
		{
			cur_cmp = queue[idx];

			if(cur_cmp.container)
			{
				out(indent = 0)
				{
					layout = addLayout();
				}
			}

			for(var child in cur_cmp.children)
			{
				child.parent = cur_cmp;
				string plt = qt_placement(child.placement);

				out(indent = 0)
				{
					<xss:e value="child.internal_id"/>->setProperty(placementName, <xss:e value="plt"/>);
				    layout->addWidget(<xss:e value="child.internal_id"/>, <xss:e value="plt"/>);
				}

			    if(child.container)
				{
				    queue += child;
					size++;
				}
			}

			if(cur_cmp.container && cur_cmp.parent)
			{
				out(indent = 0)
				{
					<xss:e value="cur_cmp.internal_id"/>->setLayout(layout);
				}
			}
			else
			{
				out(indent = 0)
				{
					setLayout(layout);
				}
			}

			idx++;
		}
	}
</xss:class>
}

<xss:e value="main_class"/>::~<xss:e value="main_class"/>()
{
    delete ui;
}

void <xss:e value="main_class"/>::changeEvent(QEvent *e)
{
    QWidget::changeEvent(e);
    switch (e->type()) {
    case QEvent::LanguageChange:
        ui->retranslateUi(this);
        break;
    default:
        break;
    }
}

XKPPlacementLayout *<xss:e value="main_class"/>::addLayout()
{
    XKPPlacementLayout *plLayout = new XKPPlacementLayout;
    layouts.append(plLayout);

    return plLayout;
}

<xss:class entry_point="generate_methods">
	// this recursive method is for generate all components, 
	// inclusively containers components with childs
	method generate_component(var cmp, var parent)
	{
		if(cmp.children)
		{
			for(var child in cmp.children)
				generate_component(child, cmp);
		}

		out()
		{
			<xss:file output="inline" src="instance.xss">
				<parameter name="main_class" access="read"/>
				<parameter name="methods" access="read_write"/>
				<parameter name="priv_vars" access="read_write"/>
				<parameter name="cmp" access="read"/>
			</xss:file>
		}
	}

	method generate_methods()
	{
		generate_component(application, null);
	}
</xss:class>
